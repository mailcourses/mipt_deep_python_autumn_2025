# Домашнее задание #03 (Классы, ООП)

### 1. Реализовать класс CustomList наследованием от list

При этом:
- `CustomList` должен наследоваться от встроенного списка `list` для получения всех методов последнего (UserList можно, но манипулировать его data напрямую не следует);
- экземпляры `CustomList` можно складывать и вычитать друг с другом, с обычными списками и с числами:
  ```py
  CustomList([5, 1, 3, 7]) + CustomList([1, 2, 7])  # CustomList([6, 3, 10, 7])
  CustomList([10]) + [2, 5]  # CustomList([12, 5])
  [2, 5] + CustomList([10])  # CustomList([12, 5])
  CustomList([2, 5]) + 10  # CustomList([12, 15])
  10 + CustomList([2, 5])  # CustomList([12, 15])

  CustomList([5, 1, 3, 7]) - CustomList([1, 2, 7])  # CustomList([4, -1, -4, 7])
  CustomList([10]) - [2, 5]  # CustomList([8, -5])
  [2, 5] - CustomList([10])  # CustomList([-8, 5])
  CustomList([2, 5]) - 10  # CustomList([-8, -5])
  10 - CustomList([2, 5])  # CustomList([8, 5])
  ```
  Возвращаться должен новый экземпляр `CustomList`, элементы которого будут результатом поэлементного сложения/вычитания элементов исходных списков.
  Сложение/вычитание с числом выполняется как сложение/вычитание каждого элемента списка с данным числом;
- при сложении/вычитании списков разной длины отсутствующие элементы меньшего списка считаются нулями;
- после сложения/вычитания исходные списки не должны изменяться;
- при сравнении (`==`, `!=`, `>`, `>=`, `<`, `<=`) экземмпляров CustomList должна сравниваться сумма элементов списков (сравнение с `list` и `int` не нужно);
- должен быть переопределен `str`, чтобы выводились элементы списка и их сумма;
- можно считать элементы списка `CustomList`, `list` и другие операнды всегда всегда целыми числами.

### 2. Тесты CustomList в отдельном модуле
Тесты должны обязательно охватывать переопределенные методы.

### 3. Зеленый пайплайн в репе
Обязательно: тесты, покрытие, flake8, pylint.
Опционально можно добавить другие инструменты, например, mypy и black.
Покрытие тестов должно составлять не менее 90%.
